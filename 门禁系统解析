门禁的时代

从整体上去看，根据门禁的需要，可以构建几个实体表：
用户信息表（User）、门禁资源表（Resource）以及二者的权限关系（user-Role-resource多对多）
和由此产生的访问记录表（VisitRecord）。

首先UserService先确定用户可以增删改查；判断某用户是什么角色；根据角色查询用户的数量及用户信息等；
ResouceService管理已有的门禁资源，可以根据用户或角色（权限）查询可访问的所有资源；添加删除某角色与门禁之间的关系；
RoleService 确定用户的角色，根据用户信息查询删除角色信息，根据门禁资源查询角色列表；用户验证，授权管理等；
VisitRecordServcie记录用户在哪一时间在哪一门禁资源做了什么，行为有：刷卡或者生物验证（如指纹、虹膜等），
若统一密码输入和内部开门则只记录事件； 根据用户信息查询访问记录等；


门禁系统工作流程：
首先，在建档时，需要给用户设置一个私人的ID号码（用户信息）。然后，门禁管理系统再对个人设置进门密码或者授权卡进行建档（角色设置）。
在刷卡检验通过之后，再进行储存，至此建档工作完成。当用户有访问需要，操作者只须一刷卡或者或者是ID号加密码。门禁管理系统会将卡内信息，与储存的信息相比较，这个验证的时间小于1秒，处理的结果通过电源控制箱后传送给门锁，实现开门。 这一行为会以日志事件的形式存储在一个地方，一段时间后统计做考勤或其他处理。




RBAC几乎无关语言、框架，主要是数据库结构上面设计；通常来讲需要5张表：
1、 auth_user // 用户表
2、 auth_node // 可授权节点表 
3、 auth_role // 角色表
4、 auth_user_role // 用户《=》角色关系对应表，因为用户和角色是many-to-many的关系（or ones-to-one，看实际情况）
5、 authenticated // 角色授权表 同样是many-to-many的关系

用户可对应N个角色（不一定非一成不变），每个角色可授权N个节点，节点权限验证的时候，使用用户的所有角色去取得已授权的节点列表，然后判断，就这么简单。开发中可能会根据实际情况有一些变动，灵活处理即可。

另外说一句，Flask有RBAC的实现方案，不过没用过，github上面关注度也不高，给传送门吧 https://github.com/shonenada/flask-rbac



按照下面几个措施，保证MySQL的输入输出没有乱码：
1 Python文件设置编码 utf-8 （文件前面加上 #encoding=utf-8)
2 MySQL数据库charset=utf-8
3 Python连接MySQL是加上参数 charset=utf8
4 设置Python的默认编码为 utf-8 (sys.setdefaultencoding(utf-8)
Python代码：

#encoding=utf-8
import sys
import MySQLdb

reload(sys)
sys.setdefaultencoding('utf-8')

db=MySQLdb.connect(user='root',charset='utf8')
cur=db.cursor()
cur.execute('use mydb')
cur.execute('select * from mytb limit 100')

f=file("/home/user/work/tem.txt",'w')

for i in cur.fetchall():
    f.write(str(i))
    f.write(" ")

f.close()
cur.close()



在Many2Many 关系的设计时，从关联表转换为关联对象，定义新标签，在查询修改上提高效率、。
但是在写入数据库的同时，会只保留一份user-role的关系。


ABAC 会话的理解？

持久的AcSession与内存中的AcSession：持久AcSession是对内存中的AcSession的持久跟踪，是对实现会话级的动态
责任分离特性的必要准备。

持久的AcSession是这样一个概念，一个账户在第一次登录的时候会建立一个内存中的AcSession，这个AcSession会被持久化起来。用户退出系统时，会更新持久的AcSession的IsAuthenticated为false但不会删除这条AcSession记录。
用户下次登录的成功时IsAuthenticated会再次更新为true，持久的AcSession只在用户登录和退出系统时访问，
持久的AcSession的存在使得安全管理员可以持久跟踪用户会话从而有机会面向用户的AcSession建立用户
会话级的动态责任分离策略和其它一些高级的操作。

一个账户可以对应多个AcSession，安全管理员可以控制哪个AcSession在什么情况下激活而哪些AcSession不能激活
（比如为某个账户建立两个AcSession分别对这两个AcSession的激活角色施加影响从而使得两个AcSession具有不同的权限集，
一个账户可以对应多个AcSession但通常只会激活一个AcSession，比如两个AcSession中的一个在早上8点到下午5点是可以
激活的，而另一个在下午5点到第二天早上8点是可以激活的）。安全管理员可以为某个账户建立新的AcSession
但不马上切换为它，安全管理员针对这个AcSession进行会话级的动态责任分离授权并测试符合预期后再禁用
用户原来的AcSession切换为新的AcSession，

系统可以让AcSession被禁用的那个账户下线然后他再次登录就切换到新的AcSession了，系统也应该能做到
在用户不知觉的情况下平滑的切换掉他的AcSession。

这是我目前对Rbac会话的理解，希望anycmd这个开源项目可以帮助到你：http://git.oschina.net/anycmd/anycmd


页面、视图等这些东西都是场所、广场、小区、大楼、楼层、空间。资源是“可以感知到的一定程度上不变的空间”，
整个空间集中的元素被分门别类，被用一片森林来分解。
所有的资源都视作空间（问题空间），只是有些空间比人大，从而人可以进入里它面去，而有些空间比人小，
人进不去里面去或者不需要进入里面去就能解决这些小空间。比如“页面”可以看作比用户大，页面是个广场、
大楼、房子、房间，用户可以进入这种场所。而一条“产品记录”可以看作一个抽屉、茶杯、桌子、笔筒，
这种空间比用户小，用户不需要进入就可以处理它们。
每一个场所、房子、家具、抽屉、茶杯、桌子、笔筒上都绑定有与那个空间相关的操作，这些操作如果是托管的
（托管的意思是不是任何人都能通过那些操作引发运动）即是权限，这些权限被组织成组即是角色。
用户来到当地空间时激活得到他当地拥有的角色。系统发现当前用户来到了某个地方就为他激活他在当地的角色。
比如，系统发现用户打开了“产品管理”模块的首页面，于是正在当前用户打开这个页面的此时，正在此时将当
前用户拥有的产品管理相关的角色在会话中激活。用户的角色被激活标识当前用户有相应的能力了，但是用户是
否去行使自己的能力是不一定的。有时候用户登录进入系统，可能只是点了一个菜单，进去一个页面，找到
一条记录，做一个操作就出来了。对于大型系统，其用户往往拥有成百上千的角色，这些角色如果在登录时
一并激活会多占空间，而如果我们对整个系统空间划分会话场，分出家、卧室、停车场、厨房、公司、马路
等不同的子场的话，当用户进入具体的子场时再激活响应的角色，这样的话节省了内存。