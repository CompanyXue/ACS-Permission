门禁的时代

从整体上去看，根据门禁的需要，可以构建几个实体表：
用户信息表（User）、门禁资源表（Resource）以及二者的权限关系（user-Role-resource多对多）
和由此产生的访问记录表（VisitRecord）。

首先UserService先确定用户可以增删改查；判断某用户是什么角色；根据角色查询用户的数量及用户信息等；
ResouceService管理已有的门禁资源，可以根据用户或角色（权限）查询可访问的所有资源；添加删除某角色与门禁之间的关系；
RoleService 确定用户的角色，根据用户信息查询删除角色信息，根据门禁资源查询角色列表；用户验证，授权管理等；
VisitRecordServcie记录用户在哪一时间在哪一门禁资源做了什么，行为有：刷卡或者生物验证（如指纹、虹膜等），
若统一密码输入和内部开门则只记录事件； 根据用户信息查询访问记录等；


门禁系统工作流程：
首先，在建档时，需要给用户设置一个私人的ID号码（用户信息）。然后，门禁管理系统再对个人设置进门密码或者授权卡进行建档（角色设置）。在刷卡检验通过之后，再进行储存，至此建档工作完成。当用户有访问需要，操作者只须一刷卡或者或者是ID号加密码。门禁管理系统会将卡内信息，与储存的信息相比较，这个验证的时间小于1秒，处理的结果通过电源控制箱后传送给门锁，实现开门。 这一行为会以日志事件的形式存储在一个地方，一段时间后统计做考勤或其他处理。




RBAC几乎无关语言、框架，主要是数据库结构上面设计；通常来讲需要5张表：
1、 auth_user // 用户表
2、 auth_node // 可授权节点表 
3、 auth_role // 角色表
4、 auth_user_role // 用户《=》角色关系对应表，因为用户和角色是many-to-many的关系（or ones-to-one，看实际情况）
5、 authenticated // 角色授权表 同样是many-to-many的关系

用户可对应N个角色（不一定非一成不变），每个角色可授权N个节点，节点权限验证的时候，使用用户的所有角色去取得已授权的节点列表，然后判断，就这么简单。开发中可能会根据实际情况有一些变动，灵活处理即可。

另外说一句，Flask有RBAC的实现方案，不过没用过，github上面关注度也不高，给传送门吧 https://github.com/shonenada/flask-rbac



按照下面几个措施，保证MySQL的输入输出没有乱码：
1 Python文件设置编码 utf-8 （文件前面加上 #encoding=utf-8)
2 MySQL数据库charset=utf-8
3 Python连接MySQL是加上参数 charset=utf8
4 设置Python的默认编码为 utf-8 (sys.setdefaultencoding(utf-8)
Python代码：

#encoding=utf-8
import sys
import MySQLdb

reload(sys)
sys.setdefaultencoding('utf-8')

db=MySQLdb.connect(user='root',charset='utf8')
cur=db.cursor()
cur.execute('use mydb')
cur.execute('select * from mytb limit 100')

f=file("/home/user/work/tem.txt",'w')

for i in cur.fetchall():
    f.write(str(i))
    f.write(" ")

f.close()
cur.close()



在Many2Many 关系的设计时，从关联表转换为关联对象，定义新标签，在查询修改上提高效率、。
但是在写入数据库的同时，会只保留一份user-role的关系。